# Por favor, escreva seus entendimentos sobre os tópicos abaixo:

- Sobre ser melhor estudante
- Sobre cdd
- Sobre o conjunto de técnicas de código
- Sobre cada funcionalidade implementada

# Por favor faça um Fork desse projeto!

## Está em dúvida de como fazer um Fork? Não tem problema! [Aqui tem uma explicação do que entendemos que você deve considerar!](https://docs.github.com/en/github/getting-started-with-github/fork-a-repo)

1} Atualização - 08/10/2020

Sobre ser melhor estudante: nesse ponto meu contato com o material escrito me apresentou formas diferentes de como algo que antes eu fazia apenas de uma forma. Um exemplo: antes eu sempre usava JPA Repository para consultas e vendo exemplos de outras formas de realizar persistência no banco de dados conclui que para o 3 desafio do processo (prover uma api simulando o comportamento de uma rede social) usar a interface CrudRepository era o suficiente para implementar as funcionalidades desejadas. E continuando no assunto de persistência fui olhar em mais detalhes toda a hierarquia do JPA Repo e nesse ponto vi como o spring faz uso do "mandamento" de programar voltado a interface e não a implementação (este conceito eu já ouvi/vi ser mencionado em diversos textos e podcasts(hipsters.tech e nos capitulos iniciaos do Design Patterns do GoF e eu não me refiro a interface como a palacra reservada do java mas a um ponto central de acesso que esconde uma complexidade de implementação do usuário que fará uso da interface). Mesmo ouvindo esse conceito muitas VEZES achava que era algo bem "utopico" de entendê-lo mas depois de buscar saber como funciona o EntityManager e sua relação com toda a hierarquia do JPA Repo eu pode ter uma luz sobre o que seria "programar voltado para interface e não implementação" porque toda a hierarquia de interfaces de JPA Repo é uma abstração sobre o Entity Manager (que também é uma interface que tem uma classe que a implementa e que por sua vez é uma abstração do modelo OO sobre relacional para o desenvolvedor JAVA). Olhando com mais atenção na documentação pode ver o quanto cada classe que faz a implementação "pesa" ao ser trazida para a aplicação através da injeção de dependência. Por peso eu me refiro aos métodos em cada uma dessas interfaces e os mesmo tempo a quantidade de classes usadas (acoplamentos que as implementações usam para dar corpo aos métodos do contrato da interface), porque a memória é um recurso caro e por isso é preciso ter cuidado com o que cada uma dessas interfaces acaba trazendo para aplicação ao adotá-la no desenvolvimento. Exemplo: para uma aplicação que tem como regra negócio ordenar uma lista de elementos ou fazer a exibição destes em quantias por vez é usada a interface JPA Repository, para situações onde as funções se resumem a criação, pesquisa, atualização e exclusão é a apropriado usar a CRUD Repository. Opcionalmente EntityManager pode ser usada para atender a ambas os cenários descritos antes mas vai exigir do desenvolvedor um conhecimento profundo do seu funcionamento pois o uso dessa interface exige conhecer detalhes de seu funcionamento e isso em termos de tempo pode custar bastante para criar funcionalidades e por isso interfaces como JPA Repository e CRUD Repository são abstrações acima de Entity Manager, ou seja, poupam o desenvolver detalhes dando-lhe mais agilidade na hora de criar soluções para regras de negócio. 

27/10/2020

Sobre cdd - fazer a contagem de pontos para quantificar complexidade de código tem sido um constante exercício, além de fazer o código funcionar também é preciso ter um cuidado na escrita para que a próxima pessoa não faça um grande esforço cognitivo para entender o que está declarado nas linhas de código. Antes de conhecer o CDD, particularmente já tentava/fazia um esforço escrever códigos légiveis mas o com o CDD eu consegue reforçar mais ainda isso. Uam coisa que notei ao concluir o primeiro desafio é que os pontos tendem a estourar ou se aproximar do limite(de acordo com o estabelecido com cada camada do sistema) quando as interações/dependências entre classes do negócio começam a aumentar, por exemplo em uma Compra de livros há outras entidades do negócio que são necessário para o fluxo de comprar ocorra corretamente. Nesse ponto é preciso extrair dados de outras entidades, validar entradas, realizar processamentos para obter outros dados. Esse conjunto de ações se torna possível com a interação de muitas classes do negócio mas ao mesmo tempo surgi a necessidade de refatoração vai surgir para que as métricas do CDD sejam mantidas. São tarefas que demandam branchs de código, acoplamentos e uso de funções (java 8) para que ocorra a execução sem exceções e a funcionalidade definida seja atentidade. 

Sobre o conjunto de técnicas de código: durante a criação do código busquei aplicar sempre  as técnicas que vi no bootcampo: não expor entidades na borda e ao mesmo não expor também detalhes na saída de dados com o uso de classes que encapsulam dados(para que a serialização dos objetos não ocorra com classes de demonío), não serializar/desserializar classes do dominínio diretamento no controller, usar construtores para informações obrigatórias, não fazer uso indiscrimado de getters e setters( se usar é apenas sob uma necessidade que justifique o uso), retornar objetos de classe do dominío através das classes que estão na bordar (DTO's/classes request) , deixar pistas: construtores que não devem ser usados mas que estão ali porque o framework precisa, deixar comentários que facilitam o entendimento de partes que julguei mais complexas. Além dos pontos acimas também fiz diversas contagem de carga intrisica para o CDD em várias classes da aplicação para exercitar essa técnica.

Sobre cada funcionalidade implementada: semelhante ao que foi dito sobre CDD as dificuldades em abstrair o que era preciso (para que cada funcionalidade atendesse ao caso de uso) surgiram quando o número de interações entre classes do negócio começavam aumentar. Exemplo para criar o fluxo de pagamento parte dele pediu para a aplicação estar preparada para receber um JSON que continha os dados do carrinho de compras, outra parte pedia para que a aplicação recebesse um copum que eventualmente seria ou não aplicado (pois uma compra pode existir sem cupom) e pensar isso no back end foi algo que demorei para abstrair. 

ATUALIZAÇÃO 04/11/2020

Proposta 

FEIGN

O que é Feign? é um declarador de serviços web. Torna a escrita de web services mais fácil. Para dizer para a aplicação SpringBoot que o Feign será usado é preciso usar a anotação @EnableFeignClients no arquivo que faz o start da aplicação. Esta anotação irá tornar as interfaces que declaram ser Feign Clients
componentes no Spring. Para usar o Fiegn é preciso criar uma interface e anota-lá com @FeignClient. Na anotação @FeignClient para configurar um cliente de API são usados parâmetros. O parâmetro value recebe um valor arbitrário para designar o nome do cliente. Com o argumento 'url' é especificado o caminho da API. Desde que uma interface seja um cliente Feign, é possível usar as annotations do Spring Web para declarar outros endereços de API's diferentes para serem consumidas por uma mesma aplicação.
OBS: Na anotação @FeignClient em versões anteriores era precisa informar apenas o atributo'url', atualmente é obrigatório forncer o nome da api no atributo 'name'. Também é preciso declarar no application.properties a chave-valor 'feign.analise-url=http://localhost:9999/' que indica em qual porta está rodando a API (cuja o feign é cliente) a ser consumida na aplicação. Em tempo de execução o valor na parâmetro URL (na interface que declara ser um cliente Feign) será substuído pelo valor da chave presente no application.properties devido ao place holder ("${feign.analise-url}") declarada na url.

HEALTH CHECK

No contexto de uma aplicação web é um serviço que ajuda a identificar se a aplicação está funcionando conforme o esperado, se há algum crash na API ou demasiada carga. De posse dessas informações a implemtação de Health Check na API é capaz de tomar decisões para remediar a situação (dentre as situações acima) inesperada. Dentre as medidas poder haver deslisgamento da API ou restart dela em outro servidor. Para que a plataforma consiga operar conforme o descrito anteriormente é preciso expor ou destinar alguma operação na API para que a plataforma consiga fazer a chamada desta operação e em seguida verificar se o funcionamente da API está normal.

Em contexto de API's REST, o método GET pode ser usado para a operação de checagem da "saúde" do sistema. A plataforma Health Check usada no Spring Boot se  chama Actuator, ou seja, em aplicações Spring o Actuator fará a "triagem" do funcionamento da API. Para verificar o end point da operação de check-n do Actuator usar '/actuator' no endereço da API.

DICA: O DESENVOLVEDOR DEVE DESDE O INÍCIO DA API INCORPORAR ESSE PADRÃO, PARA QUE TODO O PROJETO/SERVIÇO CRIADO ESTEJA COM A IMPLEMENTAÇÃO DESTE PADRÃO.



